import type { Context, RelationField } from "../../../types";
import type {
    AST,
    CreateAST,
    NestedCreateAST,
    ConnectAST,
    ConnectOrCreateAST
} from "../GraphQLInputAST/GraphQLInputAST";
import type { Visitor } from "../GraphQLInputAST/types";
import * as CypherBuilder from "../../cypher-builder/CypherBuilder";
import { getAutoGeneratedFields, fieldToSetParam } from "../utils";
import createRelationshipValidationString from "../../create-relationship-validation-string";

export class UnwindCreateVisitor implements Visitor<CypherBuilder.Clause> {
    unwindVar: CypherBuilder.Variable;
    context: Context;
    rootNode: CypherBuilder.Node | undefined;
    clause: CypherBuilder.Clause | undefined;

    constructor(unwindVar: CypherBuilder.Variable, context: Context) {
        this.unwindVar = unwindVar;
        this.context = context;
    }

    getRootNode(): CypherBuilder.Node | undefined {
        return this.rootNode;
    }

    visitNode(ast: AST): CypherBuilder.Clause {
        return new CypherBuilder.Return(new CypherBuilder.Literal("s"));
    }

    visitCreate(create: CreateAST): CypherBuilder.Clause {
        const [rootVariable, clause] = createBlock(create, this.unwindVar, this.context, this);
        this.rootNode = rootVariable;
        this.clause = clause;
        return clause;
    }

    visitNestedCreate(nestedCreate: NestedCreateAST): CypherBuilder.Clause {
        return new CypherBuilder.Return(new CypherBuilder.Literal("s"));
    }

    visitConnect(connect: ConnectAST): CypherBuilder.Clause {
        return new CypherBuilder.Return(new CypherBuilder.Literal("s"));
    }

    visitConnectOrCreate(connectOrCreate: ConnectOrCreateAST): CypherBuilder.Clause {
        return new CypherBuilder.Return(new CypherBuilder.Literal("s"));
    }

    build(): [CypherBuilder.Node? , CypherBuilder.Clause?] {
        return [this.rootNode, this.clause];
    }
}

export class RelationshipVisitor implements Visitor<CypherBuilder.Clause | undefined> {
    unwindVar: CypherBuilder.Variable;
    parentVar: CypherBuilder.Variable;
    context: Context;

    constructor(unwindVar: CypherBuilder.Variable, parentVar: CypherBuilder.Variable, context: Context) {
        this.unwindVar = unwindVar;
        this.parentVar = parentVar;
        this.context = context;
    }

    visitNode(ast: AST): CypherBuilder.Clause {
        return new CypherBuilder.Return(new CypherBuilder.Literal("s"));
    }

    visitCreate(create: CreateAST): undefined {
        return undefined;
    }

    visitNestedCreate(nestedCreate: NestedCreateAST): CypherBuilder.Clause {
        return nestedCreateBlock(nestedCreate, this.context, this.parentVar, this.unwindVar);
    }

    visitConnect(connect: ConnectAST): CypherBuilder.Clause {
        return new CypherBuilder.Return(new CypherBuilder.Literal("s"));
    }

    visitConnectOrCreate(connectOrCreate: ConnectOrCreateAST): CypherBuilder.Clause {
        return new CypherBuilder.Return(new CypherBuilder.Literal("s"));
    }
}


function createBlock(
    create: CreateAST,
    unwindVar: CypherBuilder.Variable,
    context: Context,
    visitor: UnwindCreateVisitor
): [CypherBuilder.Node, CypherBuilder.Clause] {
    const labels = create.node.getLabels(context);
    const currentNode = new CypherBuilder.Node({
        labels,
    });

    const setProperties = [...create.nodeProperties].map((property: string) =>
        fieldToSetParam(create.node, currentNode, property, unwindVar.property(property))
    ) as CypherBuilder.SetParam[];
    const autogeneratedProperties = getAutoGeneratedFields(create.node, currentNode);

    const createClause = new CypherBuilder.Create(currentNode).set(...setProperties, ...autogeneratedProperties);

    const relationshipValidationClause = new CypherBuilder.RawCypher((env: CypherBuilder.Environment) => {
        const validationStr = createRelationshipValidationString({
            node: create.node,
            context,
            varName: env.getVariableId(currentNode),
        });
        const cypher = [] as string[];
        if (validationStr) {
            cypher.push(`WITH ${env.getVariableId(currentNode)}`);
            cypher.push(validationStr);
        }
        return cypher.join("\n");
    });
    if (create.childrens) {
        const relationshipVisitor1 = new RelationshipVisitor(unwindVar, currentNode, context);
        const childrenClause = create.childrens.map((children) => children.accept(relationshipVisitor1));
        return [currentNode, CypherBuilder.concat(createClause, ...childrenClause, relationshipValidationClause)];
    }
    return [currentNode, CypherBuilder.concat(createClause, relationshipValidationClause)];
}


function nestedCreateBlock(
    nestedCreate: NestedCreateAST,
    context: Context,
    parentVar: CypherBuilder.Variable,
    unwindVar: CypherBuilder.Variable
) {
    const node = nestedCreate.node;
    const relationship = nestedCreate.relationship;
    const relationshipPropertyPath = nestedCreate.relationshipPropertyPath;
    const blockWith = new CypherBuilder.With(parentVar, unwindVar);
    const createUnwindVar = new CypherBuilder.Variable();
    const createUnwindClause = new CypherBuilder.Unwind([
        unwindVar.property(relationshipPropertyPath).property("create"),
        createUnwindVar,
    ]);
    const labels = node.getLabels(context);
    const currentNode = new CypherBuilder.Node({
        labels,
    });
    const nodeVar = new CypherBuilder.Variable();
    const edgeVar = new CypherBuilder.Variable();
    const withCreate = new CypherBuilder.With(
        [createUnwindVar.property("node"), nodeVar],
        [createUnwindVar.property("edge"), edgeVar],
        parentVar
    );
    const createClause = new CypherBuilder.Create(currentNode);
    // TODO: check the correct direction
    const relationshipClause = new CypherBuilder.Relationship({
        source: currentNode,
        target: parentVar as CypherBuilder.Node,
        type: (relationship[0] as RelationField).type,
    });
    const mergeClause = new CypherBuilder.Merge(relationshipClause);

    const setPropertiesNode = nestedCreate.nodeProperties.map((property: string) =>
        fieldToSetParam(node, currentNode, property, nodeVar.property(property))
    ) as CypherBuilder.SetParam[];
    const autogeneratedProperties = getAutoGeneratedFields(node, currentNode);
    // eslint-disable-next-line no-new
    createClause.set(...setPropertiesNode, ...autogeneratedProperties);
    if (nestedCreate.edgeProperties) {
        // TODO: modify CypherBuilder.Merge to support WithSet
        /*      const setPropertiesEdge = edgeProperties.map((property) => {
                    return [relationshipClause.property(property), edgeVar.property(property)];
                }) as CypherBuilder.SetParam[]; */
    }

    const subQueryStatements = [
        blockWith,
        createUnwindClause,
        withCreate,
        createClause,
        mergeClause,
    ] as (undefined | CypherBuilder.Clause)[];
    const relationshipValidationClause = new CypherBuilder.RawCypher((env: CypherBuilder.Environment) => {
        const validationStr = createRelationshipValidationString({
            node,
            context,
            varName: env.getVariableId(currentNode),
        }) as string;
        const cypher = [] as string[];
        if (validationStr) {
            cypher.push(`WITH ${env.getVariableId(currentNode)}`);
            cypher.push(validationStr);
        }
        return cypher.join("\n");
    });
    if (nestedCreate.childrens) {
        const relationshipVisitor1 = new RelationshipVisitor(createUnwindVar, currentNode, context);
        subQueryStatements.push(...nestedCreate.childrens.map((children => children.accept(relationshipVisitor1))));
    }
    subQueryStatements.push(relationshipValidationClause);
    subQueryStatements.push(new CypherBuilder.Return(CypherBuilder.collect(new CypherBuilder.Literal(null))));
    const subQuery = CypherBuilder.concat(...subQueryStatements);
    const callClause = new CypherBuilder.Call(subQuery);
    const outsideWith = new CypherBuilder.With(parentVar, unwindVar);
    return CypherBuilder.concat(outsideWith, callClause);
}
