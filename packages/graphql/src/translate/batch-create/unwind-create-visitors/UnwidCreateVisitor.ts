/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { Context } from "../../../types";
import type Relationship from "../../../classes/Relationship";
import type { Visitor, ICreateAST, INestedCreateAST } from "../GraphQLInputAST/GraphQLInputAST";
import type { CreateInput } from "../types";
import { getAutoGeneratedFields, fieldToSetParam } from "../utils";
import Cypher from "@neo4j/cypher-builder";
import createRelationshipValidationString from "../../create-relationship-validation-string";
import type { CallbackBucket } from "../../../classes/CallbackBucket";
import { filterTruthy } from "../../../utils/utils";
import { Neo4jGraphQLError } from "../../../classes";

export class UnwindCreateVisitor implements Visitor {
    unwindVar: Cypher.Variable;
    callbackBucket: CallbackBucket;
    context: Context;
    rootNode: Cypher.Node | undefined;
    clause: Cypher.Clause | undefined;
    rawInput: CreateInput;
    parentVar: Cypher.Variable | undefined;

    constructor(
        unwindVar: Cypher.Variable,
        callbackBucket: CallbackBucket,
        context: Context,
        rawInput: any,
        parentVar?: Cypher.Variable
    ) {
        this.unwindVar = unwindVar;
        this.callbackBucket = callbackBucket;
        this.context = context;
        this.rawInput = rawInput;
        this.parentVar = parentVar;
    }

    visitCreate(create: ICreateAST): void {
        const labels = create.node.getLabels(this.context);
        const currentNode = new Cypher.Node({
            labels,
        });

        const setProperties = [...create.nodeProperties].map((property: string) =>
            fieldToSetParam(create.node, currentNode, property, this.unwindVar.property(property))
        );
        const autogeneratedProperties = getAutoGeneratedFields(create.node, currentNode);

        const createClause = new Cypher.Create(currentNode).set(...setProperties, ...autogeneratedProperties);

        const relationshipValidationClause = new Cypher.RawCypher((env: Cypher.Environment) => {
            const validationStr = createRelationshipValidationString({
                node: create.node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [] as string[];

            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        let childrensClause;
        if (create.childrens) {
            childrensClause = create.childrens.map((children) => {
                const nestedVisitor = new UnwindCreateVisitor(
                    this.unwindVar,
                    this.callbackBucket,
                    this.context,
                    this.rawInput,
                    currentNode
                );
                children.accept(nestedVisitor);
                return nestedVisitor.build()[1];
            });
        }
        this.rootNode = currentNode;
        const clause = Cypher.concat(
            ...filterTruthy([
                createClause,
                ...childrensClause,
                relationshipValidationClause,
                new Cypher.Return(currentNode),
            ])
        );
        this.clause = new Cypher.Call(clause).innerWith(this.unwindVar);
    }

    visitNestedCreate(nestedCreate: INestedCreateAST): void {
        if (!this.parentVar) throw new Neo4jGraphQLError("Generic Error");
        const { node, relationship, relationshipPropertyPath } = nestedCreate;
        const blockWith = new Cypher.With(this.parentVar, this.unwindVar);
        const createUnwindVar = new Cypher.Variable();
        const createUnwindClause = new Cypher.Unwind([
            this.unwindVar.property(relationshipPropertyPath).property("create"),
            createUnwindVar,
        ]);
        const labels = node.getLabels(this.context);
        const currentNode = new Cypher.Node({
            labels,
        });
        const nodeVar = new Cypher.Variable();
        const edgeVar = new Cypher.Variable();
        const withCreate = new Cypher.With(
            [createUnwindVar.property("node"), nodeVar],
            [createUnwindVar.property("edge"), edgeVar],
            this.parentVar
        );
        const createClause = new Cypher.Create(currentNode);
        if (!relationship[0]) {
            throw new Error("Nested created nodes should belong to a parent");
        }

        const relationshipClause = new Cypher.Relationship({
            source: currentNode,
            target: this.parentVar as Cypher.Node,
            type: relationship[0].type,
        });

        if (relationship[0].direction === "OUT") {
            relationshipClause.reverse();
        }

        const mergeClause = new Cypher.Merge(relationshipClause);

        const setPropertiesNode = nestedCreate.nodeProperties.map((property: string) =>
            fieldToSetParam(node, currentNode, property, nodeVar.property(property))
        );
        const autogeneratedProperties = getAutoGeneratedFields(node, currentNode);

        createClause.set(...setPropertiesNode, ...autogeneratedProperties);
        if (nestedCreate.edgeProperties && nestedCreate.edgeProperties.length && nestedCreate.edge) {
            const setPropertiesEdge = nestedCreate.edgeProperties.map((property) => {
                return fieldToSetParam(
                    nestedCreate.edge as Relationship,
                    relationshipClause,
                    property,
                    edgeVar.property(property)
                );
            });
            const autogeneratedEdgeProperties = getAutoGeneratedFields(nestedCreate.edge, relationshipClause);
            mergeClause.set(...setPropertiesEdge, ...autogeneratedEdgeProperties);
        }

        const subQueryStatements = [blockWith, createUnwindClause, withCreate, createClause, mergeClause] as (
            | undefined
            | Cypher.Clause
        )[];
        const relationshipValidationClause = new Cypher.RawCypher((env: Cypher.Environment) => {
            const validationStr = createRelationshipValidationString({
                node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [] as string[];
            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        if (nestedCreate.childrens) {
            const clauses = nestedCreate.childrens.map((children) => {
                const nestedVisitor = new UnwindCreateVisitor(
                    nodeVar,
                    this.callbackBucket,
                    this.context,
                    this.rawInput,
                    currentNode
                );
                children.accept(nestedVisitor);
                return nestedVisitor.build()[1];
            });
            subQueryStatements.push(...clauses);
        }
        subQueryStatements.push(relationshipValidationClause);
        subQueryStatements.push(new Cypher.Return(Cypher.collect(new Cypher.Literal(null))));
        const subQuery = Cypher.concat(...subQueryStatements);
        const callClause = new Cypher.Call(subQuery);
        const outsideWith = new Cypher.With(this.parentVar, this.unwindVar);
        this.clause = Cypher.concat(outsideWith, callClause);
    }

    build(): [Cypher.Node?, Cypher.Clause?] {
        return [this.rootNode, this.clause];
    }
}
