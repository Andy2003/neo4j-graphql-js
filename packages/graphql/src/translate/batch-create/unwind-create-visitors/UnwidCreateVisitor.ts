import type { Context, RelationField, Node } from "../../../types";
import type {
    Visitor,
    IAST,
    ICreateAST,
    INestedCreateAST,
    IConnectAST,
    IConnectOrCreateAST,
} from "../GraphQLInputAST/types";
import type { CreateInput } from "../types";
import { getAutoGeneratedFields, fieldToSetParam } from "../utils";
import * as CypherBuilder from "../../cypher-builder/CypherBuilder";
import createRelationshipValidationString from "../../create-relationship-validation-string";
import createConnectAndParams from "../../create-connect-and-params";
import { CallbackBucket } from "../../../classes/CallbackBucket";


export class UnwindCreateVisitor implements Visitor<CypherBuilder.Clause> {
    unwindVar: CypherBuilder.Variable;
    context: Context;
    rootNode: CypherBuilder.Node | undefined;
    clause: CypherBuilder.Clause | undefined;
    rawInput: CreateInput;
    parentVar: CypherBuilder.Variable | undefined;
    treePath: string[];

    constructor(
        unwindVar: CypherBuilder.Variable,
        context: Context,
        rawInput: any,
        parentVar?: CypherBuilder.Variable,
        treePath?: string[]
    ) {
        this.unwindVar = unwindVar;
        this.context = context;
        this.rawInput = rawInput;
        this.parentVar = parentVar;
        this.treePath = treePath ?? [];
    }

    getRootNode(): CypherBuilder.Node | undefined {
        return this.rootNode;
    }

    visitNode(ast: IAST): CypherBuilder.Clause {
        throw new Error("Not implemented");
    }

    visitCreate(create: ICreateAST): CypherBuilder.Clause {
        const labels = create.node.getLabels(this.context);
        const currentNode = new CypherBuilder.Node({
            labels,
        });

        const setProperties = [...create.nodeProperties].map((property: string) =>
            fieldToSetParam(create.node, currentNode, property, this.unwindVar.property(property))
        ) as CypherBuilder.SetParam[];
        const autogeneratedProperties = getAutoGeneratedFields(create.node, currentNode);

        const createClause = new CypherBuilder.Create(currentNode).set(...setProperties, ...autogeneratedProperties);

        const relationshipValidationClause = new CypherBuilder.RawCypher((env: CypherBuilder.Environment) => {
            const validationStr = createRelationshipValidationString({
                node: create.node,
                context: this.context,
                varName: env.getVariableId(currentNode),
            });
            const cypher = [] as string[];
            if (validationStr) {
                cypher.push(`WITH ${env.getVariableId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        let rootVariable;
        let clause;
        if (create.childrens) {
            const nestedVisitor = new UnwindCreateVisitor(this.unwindVar, this.context, this.rawInput, currentNode);
            const childrenClause = create.childrens.map((children) => children.accept(nestedVisitor));
            [rootVariable, clause] = [
                currentNode,
                CypherBuilder.concat(createClause, ...childrenClause, relationshipValidationClause),
            ];
        } else {
            [rootVariable, clause] = [currentNode, CypherBuilder.concat(createClause, relationshipValidationClause)];
        }

        this.rootNode = rootVariable;
        this.clause = clause;
        return clause;
    }

    visitNestedCreate(nestedCreate: INestedCreateAST): CypherBuilder.Clause {
        if (!this.parentVar) throw new Error("Generic Error");
        const { node, relationship, relationshipPropertyPath } = nestedCreate;
        const blockWith = new CypherBuilder.With(this.parentVar, this.unwindVar);
        const createUnwindVar = new CypherBuilder.Variable();
        const createUnwindClause = new CypherBuilder.Unwind([
            this.unwindVar.property(relationshipPropertyPath).property("create"),
            createUnwindVar,
        ]);
        const labels = node.getLabels(this.context);
        const currentNode = new CypherBuilder.Node({
            labels,
        });
        const nodeVar = new CypherBuilder.Variable();
        const edgeVar = new CypherBuilder.Variable();
        const withCreate = new CypherBuilder.With(
            [createUnwindVar.property("node"), nodeVar],
            [createUnwindVar.property("edge"), edgeVar],
            this.parentVar
        );
        const createClause = new CypherBuilder.Create(currentNode);
        // TODO: check the correct direction
        const relationshipClause = new CypherBuilder.Relationship({
            source: currentNode,
            target: this.parentVar as CypherBuilder.Node,
            type: (relationship[0] as RelationField).type,
        });
        const mergeClause = new CypherBuilder.Merge(relationshipClause);

        const setPropertiesNode = nestedCreate.nodeProperties.map((property: string) =>
            fieldToSetParam(node, currentNode, property, nodeVar.property(property))
        ) as CypherBuilder.SetParam[];
        const autogeneratedProperties = getAutoGeneratedFields(node, currentNode);
        // eslint-disable-next-line no-new
        createClause.set(...setPropertiesNode, ...autogeneratedProperties);
        if (nestedCreate.edgeProperties) {
            // TODO: modify CypherBuilder.Merge to support WithSet
            /*      const setPropertiesEdge = edgeProperties.map((property) => {
                    return [relationshipClause.property(property), edgeVar.property(property)];
                }) as CypherBuilder.SetParam[]; */
        }

        const subQueryStatements = [blockWith, createUnwindClause, withCreate, createClause, mergeClause] as (
            | undefined
            | CypherBuilder.Clause
        )[];
        const relationshipValidationClause = new CypherBuilder.RawCypher((env: CypherBuilder.Environment) => {
            const validationStr = createRelationshipValidationString({
                node,
                context: this.context,
                varName: env.getVariableId(currentNode),
            }) as string;
            const cypher = [] as string[];
            if (validationStr) {
                cypher.push(`WITH ${env.getVariableId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        if (nestedCreate.childrens) {
            const nestedVisitor = new UnwindCreateVisitor(createUnwindVar, this.context, this.rawInput, currentNode, [
                ...this.treePath,
                relationshipPropertyPath,
            ]);
            subQueryStatements.push(...nestedCreate.childrens.map((children) => children.accept(nestedVisitor)));
        }
        subQueryStatements.push(relationshipValidationClause);
        subQueryStatements.push(new CypherBuilder.Return(CypherBuilder.collect(new CypherBuilder.Literal(null))));
        const subQuery = CypherBuilder.concat(...subQueryStatements);
        const callClause = new CypherBuilder.Call(subQuery);
        const outsideWith = new CypherBuilder.With(this.parentVar, this.unwindVar);
        return CypherBuilder.concat(outsideWith, callClause);
    }

    visitConnect(connect: IConnectAST): CypherBuilder.Clause {
        throw new Error("Not Implemented");
        return new CypherBuilder.RawCypher((env: CypherBuilder.Environment) => {
            if (!this.parentVar) throw Error("Generic Error");
            const parentVar = this.parentVar.getCypher(env);
            const varName = new CypherBuilder.Variable().getCypher(env);
            // pass the callbackBucket directly to the constructor class
            const callbackBucket: CallbackBucket = new CallbackBucket(this.context);
            const relationField = connect.relationship[0] as RelationField;
            const refNodes = connect.relationship[1] as Node[];
            const unionTypeName = relationField.union || relationField.interface ? refNodes[1].name : "";
            const path = [...this.treePath, connect.relationshipPropertyPath, "connect"];
            const locator = (_path, obj) => {
                return _path.reduce((prev, curr) => {
                    return prev && prev[curr];
                }, obj);
            };

            const whereInput = this.rawInput.reduce(
                (acc, input, index) => {
                    const loc = locator(path, input);
                    acc.where.node.OR.push({
                        AND: [
                            {
                                ...loc[0].where.node,
                                index,
                            },
                        ],
                    });
                    return acc;
                },
                { where: { node: { OR: [] } } }
            );

            return createConnectAndParams({
                withVars: [parentVar],
                value: [whereInput],
                varName,
                parentVar,
                relationField,
                context: this.context,
                callbackBucket,
                refNodes,
                labelOverride: unionTypeName,
                parentNode: connect.parent,
                fromCreate: true,
            });
        });
    }

    visitConnectOrCreate(connectOrCreate: IConnectOrCreateAST): CypherBuilder.Clause {
        throw new Error("Not Implemented");
        return new CypherBuilder.RawCypher((env: CypherBuilder.Environment) => {
            return "not implemented";
        });
    }

    build(): [CypherBuilder.Node?, CypherBuilder.Clause?] {
        return [this.rootNode, this.clause];
    }
}
