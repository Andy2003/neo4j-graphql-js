import type { Context, RelationField, Node } from "../../../types";
import type Relationship from "../../../classes/Relationship";
import type { Visitor, ICreateAST, INestedCreateAST, IConnectAST, IConnectOrCreateAST } from "../GraphQLInputAST/types";
import type { CreateInput } from "../types";
import { getAutoGeneratedFields, fieldToSetParam } from "../utils";
import * as CypherBuilder from "../../cypher-builder/CypherBuilder";
import createRelationshipValidationString from "../../create-relationship-validation-string";
import createConnectAndParams from "../../create-connect-and-params";
import { CallbackBucket } from "../../../classes/CallbackBucket";
import { filterTruthy } from "../../../utils/utils";

// import { addCallbackAndSetParamCypher } from "../../utils/callback-utils";
/* 
function locator(_path, obj) {
    return _path.reduce((prev, curr) => {
        return prev && prev[curr];
    }, obj);
}
 */
export class UnwindCreateVisitor implements Visitor<CypherBuilder.Clause> {
    unwindVar: CypherBuilder.Variable;
    context: Context;
    rootNode: CypherBuilder.Node | undefined;
    clause: CypherBuilder.Clause | undefined;
    rawInput: CreateInput;
    parentVar: CypherBuilder.Variable | undefined;
    treePath: string[];
    callbackBucket: CallbackBucket;

    constructor(
        unwindVar: CypherBuilder.Variable,
        callbackBucket: CallbackBucket,
        context: Context,
        rawInput: any,
        parentVar?: CypherBuilder.Variable,
        treePath?: string[]
    ) {
        this.unwindVar = unwindVar;
        this.callbackBucket = callbackBucket;
        this.context = context;
        this.rawInput = rawInput;
        this.parentVar = parentVar;
        this.treePath = treePath ?? ["0"];
    }

    visitNode(): CypherBuilder.Clause {
        return new CypherBuilder.Return(this.rootNode);
    }

    visitCreate(create: ICreateAST): CypherBuilder.Clause {
        const labels = create.node.getLabels(this.context);
        const currentNode = new CypherBuilder.Node({
            labels,
        });

        const setProperties = [...create.nodeProperties].map((property: string) =>
            fieldToSetParam(create.node, currentNode, property, this.unwindVar.property(property))
        );
        const autogeneratedProperties = getAutoGeneratedFields(create.node, currentNode);

        /*         const callbackParams = create.node.primitiveFields.map((field) =>
            addCallbackAndSetParamCypher(field, currentNode, locator(this.treePath, this.rawInput), this.callbackBucket, "CREATE", currentNode)
        ).filter((tuple) => tuple.length !== 0) as [CypherBuilder.PropertyRef, CypherBuilder.RawCypher][]; */

        const createClause = new CypherBuilder.Create(currentNode).set(...setProperties, ...autogeneratedProperties);

        const relationshipValidationClause = new CypherBuilder.RawCypher((env: CypherBuilder.Environment) => {
            const validationStr = createRelationshipValidationString({
                node: create.node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [] as string[];

            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        let childrensClause;
        if (create.childrens) {
            const nestedVisitor = new UnwindCreateVisitor(
                this.unwindVar,
                this.callbackBucket,
                this.context,
                this.rawInput,
                currentNode
            );
            childrensClause = create.childrens.map((children) => children.accept(nestedVisitor));
        }
        this.rootNode = currentNode;
        const clause = CypherBuilder.concat(
            ...filterTruthy([
                createClause,
                ...childrensClause,
                relationshipValidationClause,
                new CypherBuilder.Return(currentNode),
            ])
        );
        this.clause = new CypherBuilder.Call(clause).innerWith(this.unwindVar);
        return this.clause;
    }

    visitNestedCreate(nestedCreate: INestedCreateAST): CypherBuilder.Clause {
        if (!this.parentVar) throw new Error("Generic Error");
        const { node, relationship, relationshipPropertyPath } = nestedCreate;
        const blockWith = new CypherBuilder.With(this.parentVar, this.unwindVar);
        const createUnwindVar = new CypherBuilder.Variable();
        const createUnwindClause = new CypherBuilder.Unwind([
            this.unwindVar.property(relationshipPropertyPath).property("create"),
            createUnwindVar,
        ]);
        const labels = node.getLabels(this.context);
        const currentNode = new CypherBuilder.Node({
            labels,
        });
        const nodeVar = new CypherBuilder.Variable();
        const edgeVar = new CypherBuilder.Variable();
        const withCreate = new CypherBuilder.With(
            [createUnwindVar.property("node"), nodeVar],
            [createUnwindVar.property("edge"), edgeVar],
            this.parentVar
        );
        const createClause = new CypherBuilder.Create(currentNode);
        if (!relationship[0]) {
            throw new Error("Nested created nodes should belong to a parent");
        }

        const relationshipClause = new CypherBuilder.Relationship({
            source: currentNode,
            target: this.parentVar as CypherBuilder.Node,
            type: relationship[0].type,
        });

        if (relationship[0].direction === "OUT") {
            relationshipClause.reverse();
        }

        const mergeClause = new CypherBuilder.Merge(relationshipClause);

        const setPropertiesNode = nestedCreate.nodeProperties.map((property: string) =>
            fieldToSetParam(node, currentNode, property, nodeVar.property(property))
        );
        const autogeneratedProperties = getAutoGeneratedFields(node, currentNode);

        createClause.set(...setPropertiesNode, ...autogeneratedProperties);
        if (nestedCreate.edgeProperties && nestedCreate.edgeProperties.length && nestedCreate.edge) {
            const setPropertiesEdge = nestedCreate.edgeProperties.map((property) => {
                return fieldToSetParam(
                    nestedCreate.edge as Relationship,
                    relationshipClause,
                    property,
                    edgeVar.property(property)
                );
            });
            const autogeneratedEdgeProperties = getAutoGeneratedFields(nestedCreate.edge, relationshipClause);
            mergeClause.set(...setPropertiesEdge, ...autogeneratedEdgeProperties);
        }

        const subQueryStatements = [blockWith, createUnwindClause, withCreate, createClause, mergeClause] as (
            | undefined
            | CypherBuilder.Clause
        )[];
        const relationshipValidationClause = new CypherBuilder.RawCypher((env: CypherBuilder.Environment) => {
            const validationStr = createRelationshipValidationString({
                node,
                context: this.context,
                varName: env.getReferenceId(currentNode),
            });
            const cypher = [] as string[];
            if (validationStr) {
                cypher.push(`WITH ${env.getReferenceId(currentNode)}`);
                cypher.push(validationStr);
            }
            return cypher.join("\n");
        });
        if (nestedCreate.childrens) {
            const nestedVisitor = new UnwindCreateVisitor(
                nodeVar,
                this.callbackBucket,
                this.context,
                this.rawInput,
                currentNode,
                [...this.treePath, relationshipPropertyPath]
            );
            subQueryStatements.push(...nestedCreate.childrens.map((children) => children.accept(nestedVisitor)));
        }
        subQueryStatements.push(relationshipValidationClause);
        subQueryStatements.push(new CypherBuilder.Return(CypherBuilder.collect(new CypherBuilder.Literal(null))));
        const subQuery = CypherBuilder.concat(...subQueryStatements);
        const callClause = new CypherBuilder.Call(subQuery);
        const outsideWith = new CypherBuilder.With(this.parentVar, this.unwindVar);
        return CypherBuilder.concat(outsideWith, callClause);
    }

    visitConnect(connect: IConnectAST): CypherBuilder.Clause {
        throw new Error("Not Implemented");
        return new CypherBuilder.RawCypher((env: CypherBuilder.Environment) => {
            if (!this.parentVar) throw Error("Generic Error");
            const parentVar = this.parentVar.getCypher(env);
            const varName = new CypherBuilder.Variable().getCypher(env);
            // pass the callbackBucket directly to the constructor class
            const callbackBucket: CallbackBucket = new CallbackBucket(this.context);
            const relationField = connect.relationship[0] as RelationField;
            const refNodes = connect.relationship[1] as Node[];
            const unionTypeName = relationField.union || relationField.interface ? refNodes[1].name : "";
            const path = [...this.treePath, connect.relationshipPropertyPath, "connect"];
            const locator = (_path, obj) => {
                return _path.reduce((prev, curr) => {
                    return prev && prev[curr];
                }, obj);
            };

            const whereInput = this.rawInput.reduce(
                (acc, input, index) => {
                    const loc = locator(path, input);
                    acc.where.node.OR.push({
                        AND: [
                            {
                                ...loc[0].where.node,
                                index,
                            },
                        ],
                    });
                    return acc;
                },
                { where: { node: { OR: [] } } }
            );

            return createConnectAndParams({
                withVars: [parentVar],
                value: [whereInput],
                varName,
                parentVar,
                relationField,
                context: this.context,
                callbackBucket,
                refNodes,
                labelOverride: unionTypeName,
                parentNode: connect.parent,
                fromCreate: true,
            });
        });
    }

    visitConnectOrCreate(connectOrCreate: IConnectOrCreateAST): CypherBuilder.Clause {
        throw new Error("Not Implemented");
        console.info(connectOrCreate);
    }

    build(): [CypherBuilder.Node?, CypherBuilder.Clause?] {
        return [this.rootNode, this.clause];
    }
}
