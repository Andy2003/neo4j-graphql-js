[[connect]]
= Connect Subscriptions

WARNING: Subscriptions are only available as a beta; its API may change in the future. It is not recommended to use subscriptions in production environments.

Subscriptions to `CONNECT` events will listen to newly created relationships to a node of the specified type. 

NOTE: This subscription operation is **only** available for types that define relationship fields.

As relationship-specific information, the event will contain the relationship field name, as well as an object containing all relationship field names of the specified type. This object will be populated with properties according to the newly created relationship.

NOTE: A new event will be triggered for each new relationship.

This means that, if the type targeted for the subscriptions defines two or more relationships in the schema and two or more relationships are created, there will be an equal number of events triggered as the number of created relationships. Each event will have the relationships object populated with the created relationship properties for one single relationship name only - all other relationship names will have a null value.

NOTE: A relationship is defined by its type, as well as the types on both ends. This is relevant if you have multiple GraphQL types mapped to the same Neo4j label. For more information, check out the xref:subscriptions/events/connect.adoc#connect-same-label[Using Same Label] section below.

The event will also contain the properties of the nodes at both ends of the relationship, as well as the properties of the new relationship, if any.

NOTE: The `CONNECT` events represent new relationships being created and contain information about the nodes at each end of the new relationship. However, the connected nodes may or may not have previously existed. To subscribe to the node's updates, you need to use one of the `CREATE` or `UPDATE` subscriptions.

== `CONNECT` event

A subscription to a type can be made with the top-level subscription `[type]RelationshipCreated`. The subscription will contain the following fields:

* `event`: The event triggering this subscription, in this case it will always be `"CONNECT"`.
* `timestamp`: The timestamp in which the mutation was made. Note that multiple events may come with the same timestamp if triggered by the same query.
* `<typename>`: The properties of the node target to the subscription. Only top-level properties, without relationships, are available.
* `relationshipFieldName`: The field name of the newly created relationship, as part of the node target to the subscription.
* `createdRelationship`: An object having as keys all field names of the node target to the subscription which represent its relationships. For any given event, all field names but the one corresponding to `relationshipFieldName` will be null. The field name equal to `relationshipFieldName` will contain the relationship properties, if defined, as well as a `node` key containing the properties of the node on the other side of the relationship. Only top-level properties, without relationships, are available.

NOTE: Irrespective of the relationship direction in the database, the `CONNECT` event is bound to the type targeted for the subscription. The consequence is that - given a relationship between types A and B that is not reciprocal (that is, in the GraphQL schema type A defines a relationship to B but B does **not** define a relationship to A) and a GraphQL operation that creates the relationship between them - even though the two nodes will be connected in the database, only a subscription to type A will catch the `CONNECT` event. Check out the xref:subscriptions/events/connect.adoc#non-reciprocal-relationships[Non-reciprocal Relationships] section below for more details.

=== Example
Considering the following type definitions:
```graphql
type Movie {
    title: String
    genre: String
    actors: [Actor] @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
}
type Actor {
    name: String
}
interface ActedIn @relationshipProperties {
    screenTime: Int!
}
```

A subscription to any `Movie` connections would look like:
```graphql
subscription {
    movieRelationshipCreated {
        event
        timestamp
        movie {
            title
            genre
        }
        createdRelationship {
            actors {
                screenTime
                node {
                    name
                }
            }
        }
    }
}
```


=== Connections to Abstract Types

When using Abstract Types with relationships, you will need to specify one or more of the corresponding Concrete Types when performing the subscription operation.

These types are generated by the library and conform to the format `[type]EventPayload`, where `[type]` is a **Concrete Type**. 

==== Union Example
Considering the following type definitions:
```graphql
type Movie {
    title: String
    genre: String
    directors: [Director!]! @relationship(type: "DIRECTED", properties: "Directed", direction: IN)
}
union Director = Person | Actor
type Actor {
    name: String
}
type Person {
    name: String
    reputation: Int
}
interface Directed @relationshipProperties {
    year: Int!
}
```

A subscription to any `Movie` connections would look like:
```graphql
subscription {
    movieRelationshipCreated {
        event
        timestamp
        movie {
            title
            genre
        }
        createdRelationship {
           directors {
                year
                node {
                    ... on PersonEventPayload { # generated type
                        name
                        reputation
                    }
                    ... on ActorEventPayload { # generated type
                        name
                    }
                }
            }
        }
    }
}
```

==== Interface Example
Considering the following type definitions:
```graphql
type Movie {
    title: String
    genre: String
    reviewers: [Reviewer!]! @relationship(type: "REVIEWED", properties: "Review", direction: IN)
}
interface Reviewer {
    reputation: Int!
}
type Magazine implements Reviewer {
    title: String
    reputation: Int!
}
type Influencer implements Reviewer {
    name: String
    reputation: Int!
}
interface Review {
    score: Int!
}
```

A subscription to any `Movie` connections would look like:
```graphql
subscription {
    movieRelationshipCreated {
        event
        timestamp
        movie {
            title
            genre
        }
        createdRelationship {
            reviewers {
                score
                node {
                    reputation
                    ... on MagazineEventPayload { # generated type
                        title
                        reputation
                    }
                    ... on InfluencerEventPayload { # generated type
                        name
                        reputation
                    }
                }
            }
        }
    }
}
```

[[non-reciprocal-relationships]]
=== Non-reciprocal relationships

Considering the following type definitions:
```graphql
type Movie {
    title: String
    genre: String
    actors: [Actor] @relationship(type: "ACTED_IN", direction: IN, properties: "ActedIn")
    directors: [Director!]! @relationship(type: "DIRECTED", properties: "Directed", direction: IN)
}
type Actor {
    name: String
    movies: [Movie!]! @relationship(type: "ACTED_IN", properties: "ActedIn", direction: OUT)
}
type Person {
    name: String
    reputation: Int
}
union Director = Person | Actor
interface ActedIn @relationshipProperties {
    screenTime: Int!
}
interface Directed @relationshipProperties {
    year: Int!
}
```

Based on the type definitions, we can make some observations:

1. A `Movie` defines a relationship to `Actor` of type `ACTED_IN`
2. An `Actor` defines a relationship to `Movie` of type `ACTED_IN`
3. A `Movie` defines a relationship to `Director` of type `DIRECTED`
4. A `Director` is a union between an `Actor` and a `Person`
5. An `Actor` does **not** define a relationship to `Movie` of type `DIRECTED`
6. A `Person` does **not** define a relationship to `Movie` of type `DIRECTED`

These observations result in 2 very important conclusions:

1. First, by looking at #1 and #2 we can conclude that the relationship of type `ACTED_IN` is reciprocal. 
2. Second, from #3, #4, #5 and #6 we can conclude that the relationship of type `DIRECTED` is **not** reciprocal.

Let us now take a look at how we can subscribe to connections:

==== Movie
```graphql
subscription {
    movieRelationshipCreated {
        event
        timestamp
        movie {
            title
            genre
        }
        createdRelationship {
           actors { # corresponds to the `ACTED_IN` relationship type
                screenTime
                node {
                    name
                }
           }
           directors { # corresponds to the `DIRECTED` relationship type
                year
                node {
                    ... on PersonEventPayload { 
                        name
                        reputation
                    }
                    ... on ActorEventPayload {
                        name
                    }
                }
            }
        }
    }
}
```

==== Actor
```graphql
subscription {
    actorRelationshipCreated {
        event
        timestamp
        actor {
            name
        }
        createdRelationship {
           movies { # corresponds to the `ACTED_IN` relationship type
                screenTime
                node {
                    title
                    genre
                }
           }
           # no other field corresponding to the `DIRECTED` relationship type
        }
    }
}
```

NOTE: As we know from Conclusion#1, the relationship of type `ACTED_IN` is reciprocal - hence the `movies` field. 

NOTE: As we know from Conclusion#2, the relationship of type `DIRECTED` is **not** reciprocal - hence the absence of another field.

Therefore, when a new relationship of this type is made, such as by running a mutation as follows...
```graphql
mutation {
    createMovies(
        input: [
            {
                actors: {
                    create: [
                        {
                            node: {
                                name: "Keanu Reeves"
                            },
                            edge: {
                                screenTime: 420
                            }
                        }
                    ]
                },
                title: "John Wick",
                genre: "Action"
            }
        ]
    ) {
        movies {
            title
            genre
        }
    }
}
```

...two events will potentially be published, depending on whether we subscribed to `CONNECT` events on both types:
```graphql
{ 
    # 1 - movieRelationshipCreated
    event: "DISCONNECT"
    timestamp
    movie {
        title: "John Wick",
        genre: "Action"
    }
    createdRelationship {
        actors: {
            screenTime: 420,
            node: {
                name: "Keanu Reeves"
            }
        },
        directors: null
    }
},
{
    # 2 - actorRelationshipCreated
    event: "DISCONNECT"
    timestamp
    actor {
        name: "Keanu Reeves"
    }
    createdRelationship {
        movies: {
            screenTime: 420,
            node: {
                title: "John Wick",
                genre: "Action"
            }
        }
    }
}
```

==== Person

As the `Person` type does not define any relationships, it is **not** possible to subscribe to `CONNECT` events for this type.

NOTE: As we know from Conclusion#2, the relationship of type `DIRECTED` is **not** reciprocal. 

Therefore, when relationships of this type are made, such as by running a mutation as follows...
```graphql
mutation {
    createMovies(
        input: [
            {
                directors: {
                    Actor: { # relationship 1
                        create: [
                            {
                                node: {
                                    name: "Woody Allen"
                                },
                                edge: {
                                    year: 1989
                                }
                            }
                        ]
                    },
                    Person: { # relationship 2
                        create: [
                            {
                                node: {
                                    name: "Francis Ford Coppola",
                                    reputation: 100
                                },
                                edge: {
                                    year: 1989
                                }
                            }
                        ]
                    }   
                },
                title: "New York Stories",
                genre: "Comedy"
            }
        ]
    ) {
        movies {
            title
            genre
        }
    }
}
```

...two events will potentially be published, depending on whether we subscribed to `CONNECT` events on the `Movie` type:
```graphql
{ 
    # relationship 1
    event: "DISCONNECT"
    timestamp
    movie {
        title: "New York Stories",
        genre: "Comedy"
    }
    createdRelationship {
        actors: null,
        directors: {
            year: 1989,
            node: {
                name: "Woody Allen"
            }
        }
    }
},
{ 
    # relationship 2
    event: "DISCONNECT"
    timestamp
    movie {
        title: "New York Stories",
        genre: "Comedy"
    }
    createdRelationship {
        actors: null,
        directors: {
            year: 1989,
            node: {
                 name: "Francis Ford Coppola",
                reputation: 100
            }
        }
    }
}
```

[[connect-same-label]]
=== Types using the same Neo4j label

One other case that deserves special consideration is overriding the label in Neo4j for a specific GraphQL type. 
This can be achieved using the `@node` directive, by specifying the `label` argument.

Consider the following type definitions:
```graphql
type Actor @node(label: "Person") {
    name: String
    movies: [Movie!]! @relationship(type: "PART_OF", direction: OUT)
}
typePerson {
    name: String
    movies: [Movie!]! @relationship(type: "PART_OF", direction: OUT)
}
type Movie {
    title: String
    genre: String
    people: [Person!]!  @relationship(type: "PART_OF", direction: IN)
    actors: [Actor!]!  @relationship(type: "PART_OF", direction: IN)
}
```

Although we have 3 GraphQL types, in Neo4j there will only ever be 2 types of nodes: labeled `Movie` or labeled `Person`. 

At the database level there is no distinction between `Actor` and `Person`. Therefore, when creating a new relationship of type `PART_OF`, there will be one event for each of the 2 types.

Considering the following subscriptions:

```graphql
subscription {
    movieRelationshipCreated {
        event
        timestamp
        movie {
            title
            genre
        }
        createdRelationship {
           people { # corresponds to the `PART_OF` relationship type
                node {
                    name
                }
           }
           actors { # corresponds to the `PART_OF` relationship type
                node {
                    name
                }
           }
        }
    }
}

subscription {
    actorRelationshipCreated {
        event
        timestamp
        actor {
            name
        }
        createdRelationship {
           movies { # corresponds to the `PART_OF` relationship type
                node {
                    title
                    genre
                }
           }
        }
    }
}
```

...running a mutation as follows...
```graphql
mutation {
    createMovies(
        input: [
            {
                people: { # relationship 1
                    create: [
                        {
                            node: {
                                name: "John Logan"
                            }
                        }
                    ]
                },
                actors: {  # relationship 2
                    create: [
                        {
                            node: {
                                name: "Johnny Depp"
                            }
                        }
                    ]
                },
                title: "Sweeney Todd",
                genre: "Horror"
            }
        ]
    ) {
        movies {
            title
            genre
        }
    }
}
```

...results in the following events:
```graphql
{ 
    # relationship 1 `people` - for GraphQL types `Movie`, `Person`
    event: "DISCONNECT"
    timestamp
    movie {
        title: "Sweeney Todd",
        genre: "Horror"
    }
    createdRelationship {
        people: {
            node: {
                name: "John Logan"
            }
        },
        actors: null
    }
},
{ 
    # relationship 1 `people` - for GraphQL types `Movie`, `Actor`
    event: "DISCONNECT"
    timestamp
    movie {
        title: "Sweeney Todd",
        genre: "Horror"
    }
    createdRelationship {
        people: null,
        actors: {
            node: {
                name: "John Logan"
            }
        }
    }
},
{ 
    # relationship 1 `movies` - for GraphQL types `Actor`, `Movie`
    event: "DISCONNECT"
    timestamp
    actor {
        name: "John Logan"
    }
    createdRelationship {
        movies: {
            node: {
                title: "Sweeney Todd",
                genre: "Horror"
            }
        }
    }
},
{ 
    # relationship 2 `actors` - for GraphQL types `Movie`,`Person`
    event: "DISCONNECT"
    timestamp
    movie {
        title: "Sweeney Todd",
        genre: "Horror"
    }
    createdRelationship {
        people: {
            node: {
                name: "Johnny Depp"
            }
        },
        actors: null
    }
},
{ 
    # relationship 2 `actors` - for GraphQL types `Movie`, `Actor`
    event: "DISCONNECT"
    timestamp
    movie {
        title: "Sweeney Todd",
        genre: "Horror"
    }
    createdRelationship {
        people: null,
        actors: {
            node: {
                name: "Johnny Depp"
            }
        }
    }
},
{ 
    # relationship 2 `movies` - for GraphQL types `Actor`, `Movie`
    event: "DISCONNECT"
    timestamp
    actor {
        name: "Johnny Depp"
    }
    createdRelationship {
        movies: {
            node: {
                title: "Sweeney Todd",
                genre: "Horror"
            }
        }
    }
},
```

Had we subscribed to `` as well, we would have received two more events:
```graphql
{ 
    # relationship 1 `movies` - for GraphQL types `Person`, `Movie`
    event: "DISCONNECT"
    timestamp
    actor {
        name: "John Logan"
    }
    createdRelationship {
        movies: {
            node: {
                title: "Sweeney Todd",
                genre: "Horror"
            }
        }
    }
},
{ 
    # relationship 2 `movies` - for GraphQL types `Person`, `Movie`
    event: "DISCONNECT"
    timestamp
    actor {
        name: "Johnny Depp"
    }
    createdRelationship {
        movies: {
            node: {
                title: "Sweeney Todd",
                genre: "Horror"
            }
        }
    }
},
```